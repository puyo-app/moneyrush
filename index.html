<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>1min Money Rush</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* Reset & Layout Fixes for Mobile */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh; /* Dynamic Viewport Height */
            overflow: hidden; /* Disable Scroll */
            touch-action: none; /* Disable native gestures */
            background-color: #1a202c;
            font-family: 'Roboto', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #app {
            height: 100dvh;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Digital Clock */
        .font-digital { font-family: 'Black Ops One', cursive; font-variant-numeric: tabular-nums; }

        /* Grid Layout - Strictly Fixed */
        .board-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .game-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 6px;
            /* Ensure grid is square but fits within available space */
            width: 100%;
            max-width: 90vw; 
            aspect-ratio: 1 / 1; 
            max-height: 50vh; /* Don't let it grow too tall */
        }

        .cell {
            background: #2d3748;
            border-radius: 8px;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            /* Fixed Layout: Content doesn't affect size */
            width: 100%;
            height: 100%; 
        }
        
        /* Highlight valid drop target or selection */
        .cell.selected { border: 2px solid #fbbf24; }
        .cell.can-place { background: #4a5568; border: 1px dashed #fbbf24; }

        /* Panel Design */
        .panel {
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            z-index: 10;
        }
        /* Being Dragged State */
        .panel.dragging { opacity: 0.5; }

        /* Colors */
        .bg-red { background-color: #FF6B6B; color: #fff; }
        .bg-blue { background-color: #4ECDC4; color: #1a202c; }
        .bg-green { background-color: #95E1D3; color: #1a202c; }
        .bg-black { background-color: #2C3E50; color: #fff; border: 1px solid #4a5568; }

        /* Bars */
        .bar-container {
            width: 80%; height: 4px; background: rgba(0,0,0,0.3);
            margin-top: 2px; border-radius: 2px; overflow: hidden;
        }
        .bar-fill { height: 100%; transition: width 0.2s linear; }
        .bar-food { background-color: #F6E05E; }
        .bar-task { background-color: #63B3ED; }

        /* Footer / Shop Layout */
        .footer-area {
            background-color: #1f2937;
            display: flex;
            flex-direction: column;
            /* Fixed height to ensure it doesn't get pushed out */
            height: 35%; 
            max-height: 300px;
            border-top: 1px solid #374151;
            z-index: 20;
        }

        /* Floating Text */
        .float-text {
            position: absolute; font-weight: bold; color: #fbbf24;
            pointer-events: none; animation: floatUp 1s ease-out forwards;
            z-index: 50; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
        }

        /* Drag Ghost */
        .drag-ghost {
            position: fixed; width: 70px; height: 70px;
            pointer-events: none; z-index: 9999;
            opacity: 0.9; transform: translate(-50%, -50%);
            box-shadow: 0 10px 15px rgba(0,0,0,0.5);
        }

        /* Tab Button */
        .tab-btn {
            flex: 1; text-align: center; padding: 12px 0;
            background: #2d3748; color: #718096;
            font-weight: bold; font-size: 0.9rem;
            border-top: 2px solid transparent;
        }
        .tab-btn.active {
            background: #4a5568; color: #fff;
            border-top: 2px solid #fbbf24;
        }
    </style>
</head>
<body>

<div id="app">

    <header class="p-3 bg-gray-800 flex justify-between items-center shadow-md z-30 shrink-0 h-16">
        <div class="flex flex-col">
            <span class="text-[10px] text-gray-400">TIME LIMIT</span>
            <div class="font-digital text-3xl transition-colors duration-300 leading-none" 
                 :class="gameState === 'setup' ? 'text-red-500' : 'text-white'">
                {{ displayTime }}
            </div>
        </div>
        <div class="text-right">
            <span class="text-[10px] text-gray-400">FUNDS</span>
            <div class="text-2xl font-bold text-yellow-400 leading-none">
                {{ formatMoney(money) }}
            </div>
        </div>
    </header>

    <main class="board-container bg-gray-900" 
          @touchstart.prevent="handleGlobalTouch"
          @touchmove.prevent="handleGlobalMove"
          @touchend.prevent="handleGlobalEnd">
        
        <div v-if="gameState === 'result'" class="absolute inset-0 bg-black/85 z-50 flex flex-col items-center justify-center p-6 text-center">
            <h2 class="text-4xl font-bold text-white mb-4">FINISH!</h2>
            <div class="text-5xl font-bold text-yellow-400 mb-8 font-digital">{{ formatMoney(money) }}</div>
            <button @click="resetGame" class="bg-blue-500 text-white font-bold py-3 px-8 rounded-full shadow-lg">RETRY</button>
        </div>

        <div class="game-grid" ref="gridRef">
            <div v-for="(cell, index) in grid" :key="index"
                class="cell"
                :class="{ 
                    'selected': selectedCellIndex === index,
                    'can-place': selectedShopItem && canAfford(selectedShopItem)
                }"
                @mousedown="handleMouseStart(index, $event)"
                @touchstart="handleTouchStart(index, $event)"
            >
                <div v-if="cell" :class="['panel', getPanelColorClass(cell), { 'dragging': dragState.sourceIndex === index }]">
                    <div class="text-2xl mb-1">{{ getPanelIcon(cell) }}</div>
                    
                    <div v-if="cell.type === 'person'" class="text-[9px] leading-tight text-center">
                        x{{ cell.rank.toFixed(1) }}<br>P:{{cell.str}} I:{{cell.int}}
                    </div>
                    <div v-if="cell.type === 'food'" class="text-[9px] font-bold">{{ cell.hp }}</div>
                    <div v-if="cell.type === 'task'" class="text-[9px]">{{ cell.hp }}/{{ cell.maxHp }}</div>
                    <div v-if="cell.type === 'skill'" class="text-[9px]">{{ getSkillName(cell) }}</div>

                    <div v-if="cell.type === 'food'" class="bar-container"><div class="bar-fill bar-food" :style="{ width: (cell.hp / cell.maxHp * 100) + '%' }"></div></div>
                    <div v-if="cell.type === 'task'" class="bar-container"><div class="bar-fill bar-task" :style="{ width: ((cell.maxHp - cell.hp) / cell.maxHp * 100) + '%' }"></div></div>
                </div>
            </div>
        </div>

        <div v-for="ft in floatingTexts" :key="ft.id" class="float-text" :style="{ left: ft.x + 'px', top: ft.y + 'px' }">{{ ft.text }}</div>
    </main>

    <footer class="footer-area">
        
        <div class="h-12 px-4 bg-gray-900 flex items-center justify-between border-b border-gray-700 shrink-0">
            <div v-if="selectedCellIndex !== null && grid[selectedCellIndex]" class="flex items-center w-full justify-between animate-fade-in">
                <div class="text-xs text-gray-300">
                    <span class="font-bold text-white text-sm">{{ getPanelName(grid[selectedCellIndex]) }}</span>
                </div>
                <button @click="deletePanel(selectedCellIndex)" class="bg-red-500 hover:bg-red-600 text-white px-4 py-1.5 rounded-full text-xs font-bold shadow active:scale-95 transition">
                    Â£≤Âç¥ (+{{ Math.floor(grid[selectedCellIndex].cost * 0.5) }})
                </button>
            </div>
            <div v-else-if="selectedShopItem" class="flex items-center w-full justify-between animate-fade-in">
                <div class="text-xs">
                    <span class="font-bold block text-sm" :class="canAfford(selectedShopItem) ? 'text-white' : 'text-red-400'">
                        {{ selectedShopItem.name }} ({{ selectedShopItem.cost }}‰∏á)
                    </span>
                    <span class="text-gray-400">Áõ§Èù¢„Çø„ÉÉ„Éó„ÅßÈÖçÁΩÆ</span>
                </div>
                <button @click="selectedShopItem = null" class="text-gray-400 text-xs px-2">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
            <div v-else class="text-gray-500 text-xs w-full text-center">
                ‰∏ã„ÅßÈÅ∏„Çì„Åß‰∏ä„ÅßÈÖçÁΩÆ / „Éë„Éç„É´„Çí„Éâ„É©„ÉÉ„Ç∞„ÅßÁßªÂãï
            </div>
        </div>

        <div class="flex-1 overflow-x-auto p-2 flex items-center space-x-3 bg-gray-800 w-full">
            <div 
                v-for="(item, idx) in currentCategoryItems" 
                :key="idx"
                class="flex-shrink-0 w-16 h-20 rounded-lg flex flex-col items-center justify-center cursor-pointer border-2 relative transition-all active:scale-95"
                :class="[
                    selectedShopItem === item ? 'border-yellow-400 bg-gray-700' : 'border-gray-600 bg-gray-700',
                    !canAfford(item) ? 'opacity-50' : ''
                ]"
                @click="selectShopItem(item)"
            >
                <div class="text-2xl mb-1">{{ item.icon }}</div>
                <div class="text-[10px] font-bold text-center leading-none" :class="canAfford(item) ? 'text-white' : 'text-red-400'">
                    {{ item.cost }}‰∏á
                </div>
                <div class="absolute -top-1 -right-1 w-3 h-3 rounded-full border border-gray-800" :class="getColorDot(item.color)"></div>
            </div>
        </div>

        <div class="flex border-t border-gray-700 shrink-0">
            <div class="tab-btn" :class="{ active: activeTab === 'person' }" @click="activeTab = 'person'">‰∫∫</div>
            <div class="tab-btn" :class="{ active: activeTab === 'food' }" @click="activeTab = 'food'">È£ü</div>
            <div class="tab-btn" :class="{ active: activeTab === 'task' }" @click="activeTab = 'task'">„Çø„Çπ„ÇØ</div>
            <div class="tab-btn" :class="{ active: activeTab === 'skill' }" @click="activeTab = 'skill'">ÊäÄ</div>
        </div>
    </footer>

    <div v-if="dragState.isDragging && dragState.item" 
         class="drag-ghost panel" 
         :class="getPanelColorClass(dragState.item)" 
         :style="{ left: dragState.x + 'px', top: dragState.y + 'px' }">
        <div class="text-3xl">{{ getPanelIcon(dragState.item) }}</div>
    </div>

</div>

<script>
const { createApp, ref, computed, onMounted, onUnmounted, reactive } = Vue;

createApp({
    setup() {
        // --- Data ---
        const ITEMS = {
            person: [
                { id: 'p_red', name: 'ËÇâ‰ΩìÊ¥æ', type: 'person', color: 'red', cost: 30, str: 15, int: 5, rank: 1.0, icon: 'üí™' },
                { id: 'p_blue', name: 'È†≠ËÑ≥Ê¥æ', type: 'person', color: 'blue', cost: 30, str: 5, int: 15, rank: 1.0, icon: 'üß†' },
                { id: 'p_green', name: '„Éê„É©„É≥„Çπ', type: 'person', color: 'green', cost: 30, str: 10, int: 10, rank: 1.0, icon: '‚öñÔ∏è' },
                { id: 'p_black', name: '‰Ωé„Çπ„Å∫', type: 'person', color: 'black', cost: 30, str: 5, int: 5, rank: 1.0, icon: '‚ôüÔ∏è' },
            ],
            food: [
                { id: 'f_red', name: 'ËÇâ', type: 'food', color: 'red', cost: 5, hp: 200, maxHp: 200, icon: 'üçñ' },
                { id: 'f_blue', name: 'È≠ö', type: 'food', color: 'blue', cost: 5, hp: 200, maxHp: 200, icon: 'üêü' },
                { id: 'f_green', name: 'ÈáéËèú', type: 'food', color: 'green', cost: 10, hp: 200, maxHp: 200, icon: 'ü•¶' },
                { id: 'f_black', name: 'Ë¨éËÇâ', type: 'food', color: 'black', cost: 0, hp: 200, maxHp: 200, icon: '‚ò†Ô∏è' },
            ],
            task: [
                { id: 't_red', name: 'ËÇâ‰ΩìÂä¥ÂÉç', type: 'task', color: 'red', cost: 0, hp: 0, maxHp: 400, icon: 'üì¶', reward: 25 },
                { id: 't_blue', name: 'È†≠ËÑ≥Âä¥ÂÉç', type: 'task', color: 'blue', cost: 0, hp: 0, maxHp: 400, icon: 'üíª', reward: 25 },
                { id: 't_green', name: 'ÂçîÂäõÊ°à‰ª∂', type: 'task', color: 'green', cost: 0, hp: 0, maxHp: 400, icon: 'ü§ù', reward: 35 },
                { id: 't_black', name: 'Â∑®Â§ßÊ°à‰ª∂', type: 'task', color: 'black', cost: 0, hp: 0, maxHp: 1000, icon: 'üè¢', reward: 100 },
            ],
            skill: [
                { id: 's_red', name: '„ÉÄ„É≥„Éô„É´', type: 'skill', color: 'red', cost: 30, icon: 'üèãÔ∏è' },
                { id: 's_blue', name: 'ÊäÄË°ìÊõ∏', type: 'skill', color: 'blue', cost: 30, icon: 'üìö' },
                { id: 's_green', name: 'Ë¶≥ËëâÊ§çÁâ©', type: 'skill', color: 'green', cost: 30, icon: 'üåø' },
                { id: 's_black', name: 'ÊòáÈÄ≤Ëæû‰ª§', type: 'skill', color: 'black', cost: 30, icon: 'üìú' },
            ]
        };

        const gameState = ref('setup');
        const time = ref(10);
        const money = ref(100);
        const grid = ref(new Array(16).fill(null));
        const activeTab = ref('person');
        const selectedShopItem = ref(null);
        const selectedCellIndex = ref(null);
        const floatingTexts = ref([]);
        const gridRef = ref(null);

        const dragState = reactive({
            isDragging: false,
            item: null,
            sourceIndex: null,
            x: 0, y: 0,
            startTime: 0
        });

        // --- Logic Loop (Same as before but optimized) ---
        let lastTime = 0;
        let skillTimer = 0, blackSkillTimer = 0;

        const gameLoop = (timestamp) => {
            if (!lastTime) lastTime = timestamp;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (gameState.value === 'setup') {
                time.value -= dt;
                if (time.value <= 0) { time.value = 60; gameState.value = 'playing'; }
            } else if (gameState.value === 'playing') {
                time.value -= dt;
                if (time.value <= 0) { time.value = 0; gameState.value = 'result'; return; }
                updateLogic(dt);
            }
            requestAnimationFrame(gameLoop);
        };

        const getNeighbors = (idx) => {
            const row = Math.floor(idx / 4), col = idx % 4;
            return [[-1,0],[1,0],[0,-1],[0,1]].map(([r,c]) => {
                const nr = row + r, nc = col + c;
                if (nr >= 0 && nr < 4 && nc >= 0 && nc < 4) {
                    const nIdx = nr * 4 + nc;
                    return grid.value[nIdx] ? { ...grid.value[nIdx], index: nIdx } : null;
                }
                return null;
            }).filter(n => n);
        };

        const updateLogic = (dt) => {
            skillTimer += dt; blackSkillTimer += dt;
            const trigSkill = skillTimer >= 1.0;
            const trigBlack = blackSkillTimer >= 10.0;
            if (trigSkill) skillTimer = 0;
            if (trigBlack) blackSkillTimer = 0;

            grid.value.forEach((cell, idx) => {
                if (!cell) return;
                const neighbors = getNeighbors(idx);

                // Skill
                if (cell.type === 'skill') {
                    neighbors.forEach(n => {
                        const t = grid.value[n.index];
                        if (t.type === 'person') {
                            if (cell.color === 'red' && trigSkill) t.str++;
                            if (cell.color === 'blue' && trigSkill) t.int++;
                            if (cell.color === 'black' && trigBlack) {
                                t.rank = Math.min(2.0, t.rank + 0.1);
                                spawnFloatText('ÊòáÈÄ≤!', n.index);
                            }
                        }
                    });
                }

                // Person Work/Eat
                if (cell.type === 'person') {
                    // Eat
                    const foods = neighbors.filter(n => n.type === 'food').sort((a,b) => {
                        const isFavA = a.color === cell.color || a.color === 'green';
                        const isFavB = b.color === cell.color || b.color === 'green';
                        return (isFavB ? 1 : 0) - (isFavA ? 1 : 0);
                    });
                    
                    let canWork = false;
                    if (foods.length) {
                        const fIdx = foods[0].index;
                        const hasGreenSkill = neighbors.some(n => n.type === 'skill' && n.color === 'green');
                        let cost = (grid.value[fIdx].color === cell.color || grid.value[fIdx].color === 'green') ? 10 : 20;
                        if (hasGreenSkill) cost *= 0.5;
                        
                        grid.value[fIdx].hp -= cost * dt;
                        canWork = true;

                        if (grid.value[fIdx].hp <= 0) {
                            if (grid.value[fIdx].color === 'black') {
                                getNeighbors(fIdx).forEach(dead => { if(dead.type==='person') { grid.value[dead.index] = null; spawnFloatText('Ê≠ª‰∫°', dead.index); } });
                            }
                            grid.value[fIdx] = null; 
                        }
                    }

                    // Work
                    if (canWork) {
                        const tasks = neighbors.filter(n => n.type === 'task');
                        tasks.forEach(t => {
                            const task = grid.value[t.index];
                            if (task.color === 'black') {
                                // Must have black person adjacent to task
                                const tNeighbors = getNeighbors(t.index);
                                if (!tNeighbors.some(tn => tn.type === 'person' && tn.color === 'black')) return;
                            }
                            let pwr = 0;
                            if (task.color === 'red') pwr = cell.str;
                            else if (task.color === 'blue') pwr = cell.int;
                            else pwr = cell.str + cell.int;
                            
                            task.hp += (pwr / tasks.length) * dt;
                            if (task.hp >= task.maxHp) {
                                task.hp = 0;
                                const rw = Math.floor(task.reward * cell.rank);
                                money.value += rw;
                                spawnFloatText(`+${rw}`, t.index);
                            }
                        });
                    }
                }
            });
        };

        // --- Inputs (Separated Logic) ---

        // Shop Click (Select Only)
        const selectShopItem = (item) => {
            selectedShopItem.value = item;
            selectedCellIndex.value = null; // Clear board selection
        };

        // Board Touch/Click logic
        const handleStart = (idx, x, y) => {
            // Case 1: Placing Shop Item (Click/Tap)
            if (selectedShopItem.value) {
                // Wait for release to confirm placement (tap)
                return;
            }

            // Case 2: Manipulating Board Item
            if (grid.value[idx]) {
                dragState.sourceIndex = idx;
                dragState.item = { ...grid.value[idx] };
                dragState.x = x;
                dragState.y = y;
                dragState.isDragging = false; // Will set true on move
                dragState.startTime = Date.now();
                selectedCellIndex.value = idx; // Select for details
            } else {
                selectedCellIndex.value = null;
            }
        };

        const handleMove = (x, y) => {
            if (dragState.sourceIndex !== null) {
                // Threshold to start dragging
                if (!dragState.isDragging) {
                    dragState.isDragging = true;
                }
                dragState.x = x;
                dragState.y = y;
            }
        };

        const handleEnd = (targetIdx) => {
            // Shop Placement Logic (Tap)
            if (selectedShopItem.value && targetIdx !== undefined) {
                if (canAfford(selectedShopItem.value)) {
                    money.value -= selectedShopItem.value.cost;
                    // Refund if overwriting
                    if (grid.value[targetIdx]) money.value += Math.floor(grid.value[targetIdx].cost * 0.5);
                    // Place
                    const newItem = JSON.parse(JSON.stringify(selectedShopItem.value));
                    if (newItem.type === 'person') newItem.rank = 1.0;
                    grid.value[targetIdx] = newItem;
                }
                // Optional: Clear selection after place? Let's keep it for rapid placement
                // selectedShopItem.value = null; 
                return;
            }

            // Board Drag Logic
            if (dragState.isDragging && dragState.sourceIndex !== null && targetIdx !== undefined) {
                // Swap
                const src = dragState.sourceIndex;
                const dst = targetIdx;
                if (src !== dst) {
                    const temp = grid.value[dst];
                    grid.value[dst] = grid.value[src];
                    grid.value[src] = temp;
                    selectedCellIndex.value = dst;
                }
            }

            // Reset Drag
            dragState.isDragging = false;
            dragState.sourceIndex = null;
            dragState.item = null;
        };

        // Event Wrappers
        const getIndexFromPos = (x, y) => {
            if (!gridRef.value) return undefined;
            const rect = gridRef.value.getBoundingClientRect();
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return undefined;
            const cellW = rect.width / 4;
            const cellH = rect.height / 4;
            const c = Math.floor((x - rect.left) / cellW);
            const r = Math.floor((y - rect.top) / cellH);
            return r * 4 + c;
        };

        const handleMouseStart = (idx, e) => handleStart(idx, e.clientX, e.clientY);
        const handleTouchStart = (idx, e) => handleStart(idx, e.touches[0].clientX, e.touches[0].clientY);
        
        // Global listeners for drag continuity
        const handleGlobalMove = (e) => {
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            handleMove(x, y);
        };
        const handleGlobalEnd = (e) => {
            // Mouseup doesn't give coords, but we don't need accurate coords for end unless we calculate drop target here
            // For touch, we need changedTouches if we want last pos, but better to track last known pos
            const x = dragState.x; 
            const y = dragState.y;
            const targetIdx = getIndexFromPos(x, y);
            
            // Special handling for Click (Tap) vs Drag End
            // If dragging never started, and we released on a cell, it's a Tap.
            // But handleEnd logic handles "isDragging" check.
            
            // Note: If we just tapped (no drag), targetIdx is the cell we tapped.
            // We need to pass the cell index for Tap placement logic.
            // Since we don't have event.target easily for global listener, 
            // we rely on getIndexFromPos using last known coordinates.
            
            // Problem: If I tap, handleMove might not fire, so x/y are 0 or old.
            // Fix: handleStart sets initial x/y.
            
            handleEnd(targetIdx);
        };
        
        // Mouse global listeners are needed too if testing on PC
        window.addEventListener('mousemove', handleGlobalMove);
        window.addEventListener('mouseup', handleGlobalEnd);


        // --- Utils ---
        const canAfford = (item) => money.value >= item.cost;
        const deletePanel = (idx) => {
            if (grid.value[idx]) {
                money.value += Math.floor(grid.value[idx].cost * 0.5);
                grid.value[idx] = null;
                selectedCellIndex.value = null;
            }
        };
        const spawnFloatText = (text, idx) => {
            if(!gridRef.value) return;
            const rect = gridRef.value.children[idx].getBoundingClientRect();
            floatingTexts.value.push({
                id: Math.random(), text, x: rect.left + rect.width/4, y: rect.top
            });
            setTimeout(()=>floatingTexts.value.shift(), 800);
        };
        const formatMoney = (v) => Math.floor(v).toLocaleString();
        const getPanelColorClass = (i) => `bg-${i.color}`;
        const getPanelIcon = (i) => i.icon;
        const getPanelName = (i) => i.name;
        const getColorDot = (c) => `bg-${c}-500`;
        const getSkillName = (i) => ({red:'ÂäõUP',blue:'Áü•UP',green:'ÁúÅ„Ç®„Éç',black:'ÊòáÈÄ≤'}[i.color]);
        const displayTime = computed(() => {
            const t = Math.ceil(time.value);
            const m = Math.floor(t/60), s = t%60;
            return `${m}:${s.toString().padStart(2,'0')}`;
        });
        const resetGame = () => {
            grid.value.fill(null); money.value=100; time.value=10; gameState.value='setup';
        };

        onMounted(() => requestAnimationFrame(gameLoop));

        return {
            gameState, time, displayTime, money, grid, activeTab, currentCategoryItems: computed(() => ITEMS[activeTab.value]),
            selectedShopItem, selectedCellIndex, dragState, floatingTexts, gridRef,
            selectShopItem, canAfford, deletePanel, handleMouseStart, handleTouchStart, handleGlobalMove, handleGlobalEnd,
            formatMoney, getPanelColorClass, getPanelIcon, getPanelName, getColorDot, getSkillName, resetGame
        };
    }
}).mount('#app');
</script>
</body>
</html>
