<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÔºëÂàÜ„ÅßÁ®º„Åê</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        /* --- Base & Reset --- */
        :root {
            --c-red: #FF6B6B;
            --c-blue: #4ECDC4;
            --c-green: #95E1D3;
            --c-black: #2C3E50;
            --c-bg: #f7f9fc;
            --c-panel: #ffffff;
            --c-text: #333;
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; -webkit-user-select: none; }
        body {
            margin: 0; padding: 0; width: 100%; height: 100vh; height: 100dvh;
            overflow: hidden; background-color: var(--c-bg);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: var(--c-text); touch-action: none;
        }

        /* --- Layout --- */
        #app {
            display: flex; flex-direction: column; height: 95%; /* ÊåáÂÆö„ÅÆ95%Âõ∫ÂÆö */
            max-width: 600px; margin: 0 auto; position: relative;
        }
        /* Fill bottom safe area */
        .bottom-fill {
            position: absolute; bottom: -100px; left: 0; right: 0; height: 100px;
            background-color: var(--c-panel); z-index: -1;
        }

        /* --- Header --- */
        header {
            flex: 0 0 auto; padding: 10px 20px;
            display: flex; justify-content: space-between; align-items: center;
            background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.05); z-index: 10;
        }
        .timer-box { font-size: 2rem; font-weight: 800; font-variant-numeric: tabular-nums; }
        .timer-box.setup { color: var(--c-red); }
        .timer-box.main { color: var(--c-black); text-shadow: 2px 2px 0px rgba(0,0,0,0.1); }
        .money-box { font-size: 1.2rem; font-weight: bold; color: #f1c40f; text-shadow: 1px 1px 0 #b7950b; }

        /* --- Main Board --- */
        .board-container {
            flex: 1 1 auto; display: flex; align-items: center; justify-content: center;
            padding: 10px; overflow: hidden; position: relative;
        }
        .grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;
            width: 100%; aspect-ratio: 1 / 1; max-height: 100%;
        }
        .cell {
            background: #e0e6ed; border-radius: 8px; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 0.8rem; font-weight: bold; overflow: hidden;
            transition: transform 0.1s; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.05);
        }
        .cell.active { background: #fff; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer; }
        .cell.selected-target { border: 2px solid var(--c-blue); }
        .cell-content { width: 100%; height: 100%; padding: 4px; display: flex; flex-direction: column; justify-content: space-between; pointer-events: none;}
        
        /* Icons & Colors */
        .icon { font-size: 1.8rem; line-height: 1; text-align: center; margin-top: 4px;}
        .type-person { color: var(--c-black); } /* ‰∫∫„ÅØÊû†Ëâ≤„ÅßÂå∫Âà• */
        .bg-red { background-color: rgba(255, 107, 107, 0.15); border: 2px solid var(--c-red); color: var(--c-red); }
        .bg-blue { background-color: rgba(78, 205, 196, 0.15); border: 2px solid var(--c-blue); color: var(--c-blue); }
        .bg-green { background-color: rgba(149, 225, 211, 0.15); border: 2px solid var(--c-green); color: var(--c-green); }
        .bg-black { background-color: rgba(44, 62, 80, 0.15); border: 2px solid var(--c-black); color: var(--c-black); }
        
        /* Bars */
        .bar-container { width: 100%; height: 6px; background: #ddd; border-radius: 3px; overflow: hidden; margin-top: auto;}
        .bar-fill { height: 100%; transition: width 0.2s linear; }
        .bar-food { background-color: #F39C12; }
        .bar-task { background-color: #8E44AD; }
        .stats-text { font-size: 0.6rem; text-align: center; white-space: nowrap; }

        /* --- Panel --- */
        .panel {
            flex: 0 0 40%; background: var(--c-panel);
            border-top: 1px solid #eee; display: flex; flex-direction: column;
            padding-bottom: var(--safe-bottom);
        }
        /* Info Area (Top) */
        .info-area {
            flex: 0 0 50px; padding: 5px 15px; border-bottom: 1px solid #f0f0f0;
            display: flex; align-items: center; justify-content: space-between; font-size: 0.9rem;
        }
        .info-detail { font-size: 0.8rem; color: #666; }
        /* List Area (Middle) */
        .list-area {
            flex: 1; overflow-x: auto; display: flex; align-items: center; padding: 0 10px;
            -webkit-overflow-scrolling: touch;
        }
        .list-item {
            flex: 0 0 70px; height: 70px; margin-right: 10px; border-radius: 8px; border: 2px solid #eee;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 0.7rem; transition: all 0.2s;
        }
        .list-item.selected { border-color: var(--c-black); background: #f0f0f0; transform: translateY(-2px); }
        .cost-badge { background: #333; color: #fff; padding: 2px 6px; border-radius: 10px; font-size: 0.6rem; margin-top: 2px;}
        
        /* Tab Area (Bottom) */
        .tab-area {
            flex: 0 0 40px; display: flex; border-top: 1px solid #eee;
        }
        .tab {
            flex: 1; display: flex; align-items: center; justify-content: center;
            font-size: 0.9rem; font-weight: bold; color: #999;
            background: #fafafa; cursor: pointer;
        }
        .tab.active { background: #fff; color: var(--c-black); border-top: 3px solid var(--c-black); }

        /* --- Modal & Overlays --- */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 100;
            display: flex; align-items: center; justify-content: center;
        }
        .modal {
            background: #fff; padding: 20px; border-radius: 12px; width: 85%;
            text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        .modal h2 { margin: 0 0 10px; font-size: 1.5rem; }
        .modal p { margin: 10px 0; color: #555; }
        .btn {
            background: var(--c-black); color: #fff; border: none; padding: 10px 20px;
            border-radius: 6px; font-size: 1rem; font-weight: bold; cursor: pointer; margin-top: 10px;
        }
        .btn-red { background: var(--c-red); }
        .btn-close { position: absolute; top: 10px; right: 10px; background: #ddd; width: 30px; height: 30px; border-radius: 50%; border:none; font-weight:bold;}

        /* Dragging Ghost */
        .ghost {
            position: fixed; width: 80px; height: 80px; background: rgba(255,255,255,0.9);
            border: 2px solid var(--c-black); border-radius: 8px; pointer-events: none;
            z-index: 999; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="bottom-fill"></div>

        <header>
            <div class="timer-box" :class="phase === 'setup' ? 'setup' : 'main'">
                {{ formattedTime }}
            </div>
            <div class="money-box">
                {{ money }}‰∏áÂÜÜ
            </div>
        </header>

        <div class="board-container" ref="boardContainer">
            <div class="grid">
                <div v-for="(cell, index) in grid" :key="index" 
                     class="cell" 
                     :class="[
                        cell.content ? `bg-${cell.content.color}` : '',
                        cell.content ? 'active' : '',
                        dragTargetIndex === index ? 'selected-target' : ''
                     ]"
                     @touchstart.passive="handleTouchStart($event, index)"
                     @touchmove="handleTouchMove($event)"
                     @touchend="handleTouchEnd($event)"
                     @click="handleCellClick(index)">
                    
                    <div v-if="cell.content" class="cell-content">
                        <div class="stats-text" v-if="cell.content.type === 'person'">
                            Rank {{ cell.content.rank }}
                        </div>
                        <div class="icon">
                            <span v-if="cell.content.type === 'person'">ÏõÉ</span>
                            <span v-else-if="cell.content.type === 'food'">üçñ</span>
                            <span v-else-if="cell.content.type === 'task'">üìù</span>
                            <span v-else-if="cell.content.type === 'skill'">‚òÖ</span>
                        </div>
                        
                        <div class="bar-container" v-if="cell.content.type === 'food'">
                            <div class="bar-fill bar-food" :style="{ width: (cell.content.hp / cell.content.maxHp * 100) + '%' }"></div>
                        </div>
                        <div class="bar-container" v-if="cell.content.type === 'task'">
                            <div class="bar-fill bar-task" :style="{ width: (cell.content.progress / cell.content.maxProgress * 100) + '%' }"></div>
                        </div>
                        
                        <div class="stats-text">
                            <span v-if="cell.content.type === 'person'">{{cell.content.str}}/{{cell.content.int}}</span>
                            <span v-if="cell.content.type === 'skill'">{{ getSkillEffectText(cell.content) }}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="info-area">
                <div v-if="selectedPaletteItem">
                    <strong>{{ selectedPaletteItem.name }}</strong>
                    <span class="cost-badge" style="margin-left:8px">{{ selectedPaletteItem.cost }}‰∏áÂÜÜ</span>
                </div>
                <div v-else style="color:#999">„Ç¢„Ç§„ÉÜ„É†„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>
                <div v-if="selectedPaletteItem" class="info-detail">{{ selectedPaletteItem.desc }}</div>
            </div>

            <div class="list-area">
                <div v-for="item in currentCategoryItems" :key="item.id"
                     class="list-item"
                     :class="[
                        selectedPaletteItem && selectedPaletteItem.id === item.id ? 'selected' : '',
                        `bg-${item.color}`
                     ]"
                     @click="selectPaletteItem(item)">
                    <span style="font-size:1.2rem">
                        {{ item.icon }}
                    </span>
                    <span class="cost-badge">{{ item.cost }}</span>
                </div>
            </div>

            <div class="tab-area">
                <div class="tab" :class="{ active: activeTab === 'person' }" @click="activeTab = 'person'">‰∫∫</div>
                <div class="tab" :class="{ active: activeTab === 'food' }" @click="activeTab = 'food'">È£üÁâ©</div>
                <div class="tab" :class="{ active: activeTab === 'task' }" @click="activeTab = 'task'">„Çø„Çπ„ÇØ</div>
                <div class="tab" :class="{ active: activeTab === 'skill' }" @click="activeTab = 'skill'">„Çπ„Ç≠„É´</div>
            </div>
        </div>

        <div v-if="showDetailModal" class="overlay" @click.self="closeDetailModal">
            <div class="modal">
                <button class="btn-close" @click="closeDetailModal">√ó</button>
                <h2>{{ getModalTitle() }}</h2>
                <p>{{ getModalDesc() }}</p>
                <div v-if="grid[selectedGridIndex].content.type === 'person'">
                    <p>ÁèæÂú®„ÅÆRank: {{ grid[selectedGridIndex].content.rank }}</p>
                </div>
                <button class="btn btn-red" @click="deleteItem">ÂâäÈô§„Åô„Çã (ËøîÈáë„Å™„Åó)</button>
            </div>
        </div>

        <div v-if="phase === 'result'" class="overlay">
            <div class="modal">
                <h2>ÁµÇ‰∫ÜÔºÅ</h2>
                <p>ÊúÄÁµÇÊâÄÊåÅÈáë</p>
                <div style="font-size: 2.5rem; font-weight:800; color:#f1c40f; margin: 10px 0;">
                    {{ money }}<span style="font-size:1rem; color:#333">‰∏áÂÜÜ</span>
                </div>
                <button class="btn" @click="resetGame">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÈÅä„Å∂</button>
            </div>
        </div>

        <div v-if="isDragging" class="ghost" :style="{ top: ghostY + 'px', left: ghostX + 'px' }">
            <span style="font-size:2rem">{{ draggingContent?.icon }}</span>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted } = Vue;

        // Data Definitions
        const ITEM_DEFINITIONS = {
            person: [
                { id: 'p_red', name: 'ËÇâ‰ΩìÊ¥æ', color: 'red', cost: 30, type: 'person', icon: 'ÏõÉ', str: 15, int: 5, desc: 'Âäõ15 / Áü•5' },
                { id: 'p_blue', name: 'È†≠ËÑ≥Ê¥æ', color: 'blue', cost: 30, type: 'person', icon: 'ÏõÉ', str: 5, int: 15, desc: 'Âäõ5 / Áü•15' },
                { id: 'p_green', name: '„Éê„É©„É≥„Çπ', color: 'green', cost: 30, type: 'person', icon: 'ÏõÉ', str: 10, int: 10, desc: 'Âäõ10 / Áü•10' },
                { id: 'p_black', name: '‰Ωé„Çπ„Éö„ÉÉ„ÇØ', color: 'black', cost: 30, type: 'person', icon: 'ÏõÉ', str: 5, int: 5, desc: 'Âäõ5 / Áü•5 (ÈªíÊ°à‰ª∂„Å´ÂøÖÈ†à)' },
            ],
            food: [
                { id: 'f_red', name: 'Ëµ§„ÅÑËÇâ', color: 'red', cost: 5, type: 'food', icon: 'üçñ', hp: 200, desc: 'Ëµ§„ÅÆÂ•ΩÁâ© (‰ªñ„ÅØÊ∂àË≤ªÂÄç)' },
                { id: 'f_blue', name: 'Èùí„ÅÑÈ≠ö', color: 'blue', cost: 5, type: 'food', icon: 'üçñ', hp: 200, desc: 'Èùí„ÅÆÂ•ΩÁâ© (‰ªñ„ÅØÊ∂àË≤ªÂÄç)' },
                { id: 'f_green', name: 'ÈáéËèú', color: 'green', cost: 10, type: 'food', icon: 'üçñ', hp: 200, desc: 'Ë™∞„Åß„ÇÇÈÄöÂ∏∏Ê∂àË≤ª' },
                { id: 'f_black', name: 'Ë¨é„ÅÆËÇâ', color: 'black', cost: 0, type: 'food', icon: 'üçñ', hp: 200, desc: 'ÁÑ°„Åè„Å™„Çã„Å®Âë®Âõ≤„ÅåÊ≠ª„Å¨' },
            ],
            task: [
                { id: 't_red', name: 'Âäõ‰ªï‰∫ã', color: 'red', cost: 0, type: 'task', icon: 'üìù', max: 200, req: 'str', reward: 20, desc: 'ÂøÖË¶ÅÔºöÂäõ / Â†±ÈÖ¨20‰∏á' },
                { id: 't_blue', name: '‰∫ãÂãô', color: 'blue', cost: 0, type: 'task', icon: 'üìù', max: 200, req: 'int', reward: 20, desc: 'ÂøÖË¶ÅÔºöÁü• / Â†±ÈÖ¨20‰∏á' },
                { id: 't_green', name: 'Á∑èÂêàËÅ∑', color: 'green', cost: 0, type: 'task', icon: 'üìù', max: 300, req: 'both', reward: 20, desc: 'ÂøÖË¶ÅÔºöÂäõ+Áü• / Â†±ÈÖ¨20‰∏á' },
                { id: 't_black', name: 'Â∑®Â§ßÊ°à‰ª∂', color: 'black', cost: 0, type: 'task', icon: 'üìù', max: 500, req: 'both', reward: 100, desc: 'Èªí„ÅÆ‰∫∫ÂøÖÈ†à / Â†±ÈÖ¨100‰∏á' },
            ],
            skill: [
                { id: 's_red', name: 'Á≠ã„Éà„É¨', color: 'red', cost: 30, type: 'skill', icon: '‚òÖ', desc: 'Âë®Âõ≤„ÅÆÂäõ+1' },
                { id: 's_blue', name: 'ÂãâÂº∑‰ºö', color: 'blue', cost: 30, type: 'skill', icon: '‚òÖ', desc: 'Âë®Âõ≤„ÅÆÁü•+1' },
                { id: 's_green', name: 'ÁØÄÁ¥ÑË°ì', color: 'green', cost: 30, type: 'skill', icon: '‚òÖ', desc: 'Âë®Âõ≤„ÅÆÈ£üË≤ªÂçäÊ∏õ' },
                { id: 's_black', name: 'ÊòáÈÄ≤Ëæû‰ª§', color: 'black', cost: 30, type: 'skill', icon: '‚òÖ', desc: '10ÁßíÊØé„Å´Âë®Âõ≤„ÇíÊòáÈÄ≤' },
            ]
        };

        createApp({
            setup() {
                // Game State
                const phase = ref('setup'); // setup, playing, result
                const money = ref(100);
                const timeLeft = ref(10);
                const grid = ref(Array(16).fill().map(() => ({ content: null })));
                const activeTab = ref('person');
                const selectedPaletteItem = ref(null);
                
                // Modal & Interaction
                const showDetailModal = ref(false);
                const selectedGridIndex = ref(null);
                const boardContainer = ref(null);

                // Dragging State
                const isDragging = ref(false);
                const dragStartIndex = ref(null);
                const dragTargetIndex = ref(null); // Highlight drop target
                const ghostX = ref(0);
                const ghostY = ref(0);
                const draggingContent = ref(null);

                // Timer Loop
                let timerInterval = null;
                let tickCount = 0; // For 10s checks

                const currentCategoryItems = computed(() => ITEM_DEFINITIONS[activeTab.value]);

                const formattedTime = computed(() => {
                    if (phase.value === 'setup') return `START IN ${timeLeft.value}`;
                    if (phase.value === 'result') return "FINISH";
                    const m = Math.floor(timeLeft.value / 60);
                    const s = timeLeft.value % 60;
                    return `${m}:${s.toString().padStart(2, '0')}`;
                });

                // --- Game Logic Core ---

                const getNeighbors = (idx) => {
                    const row = Math.floor(idx / 4);
                    const col = idx % 4;
                    const neighbors = [];
                    // Up, Down, Left, Right
                    if (row > 0) neighbors.push(idx - 4);
                    if (row < 3) neighbors.push(idx + 4);
                    if (col > 0) neighbors.push(idx - 1);
                    if (col < 3) neighbors.push(idx + 1);
                    return neighbors;
                };

                const startGame = () => {
                    // Setup Phase Countdown
                    timerInterval = setInterval(() => {
                        timeLeft.value--;
                        if (timeLeft.value <= 0) {
                            clearInterval(timerInterval);
                            phase.value = 'playing';
                            timeLeft.value = 60;
                            tickCount = 0;
                            startMainLoop();
                        }
                    }, 1000);
                };

                const startMainLoop = () => {
                    timerInterval = setInterval(() => {
                        processGameTick();
                        timeLeft.value--;
                        if (timeLeft.value <= 0) {
                            clearInterval(timerInterval);
                            phase.value = 'result';
                        }
                    }, 1000);
                };

                const processGameTick = () => {
                    tickCount++;
                    // 1. Calculate Buffs & Reset Temp Stats
                    // Create a snapshot of buffs to apply
                    const buffs = Array(16).fill().map(() => ({ str: 0, int: 0, saveFood: false }));
                    
                    grid.value.forEach((cell, idx) => {
                        if (cell.content && cell.content.type === 'skill') {
                            const neighbors = getNeighbors(idx);
                            neighbors.forEach(nIdx => {
                                if (cell.content.id === 's_red') buffs[nIdx].str += 1;
                                if (cell.content.id === 's_blue') buffs[nIdx].int += 1;
                                if (cell.content.id === 's_green') buffs[nIdx].saveFood = true;
                                if (cell.content.id === 's_black' && tickCount % 10 === 0) {
                                    // Promotion Event
                                    if (grid.value[nIdx].content && grid.value[nIdx].content.type === 'person') {
                                        grid.value[nIdx].content.rank++;
                                    }
                                }
                            });
                        }
                    });

                    // 2. Logic for Persons (Consume & Work)
                    grid.value.forEach((cell, idx) => {
                        if (!cell.content || cell.content.type !== 'person') return;
                        
                        const p = cell.content;
                        // Apply Buffs
                        const currentStr = p.str + buffs[idx].str;
                        const currentInt = p.int + buffs[idx].int;
                        const isDiet = buffs[idx].saveFood;

                        // --- Eat Food ---
                        const neighbors = getNeighbors(idx);
                        let bestFoodIdx = -1;
                        let minConsumption = 999;

                        // Find best food
                        neighbors.forEach(nIdx => {
                            const target = grid.value[nIdx].content;
                            if (target && target.type === 'food') {
                                let consumption = 20;
                                if (p.color === target.color) consumption = 10;
                                if (target.color === 'green' || target.color === 'black') consumption = 10;
                                if (isDiet) consumption = Math.ceil(consumption / 2);

                                // Prioritize lower consumption, then just pick first
                                if (consumption < minConsumption) {
                                    minConsumption = consumption;
                                    bestFoodIdx = nIdx;
                                } else if (consumption === minConsumption && bestFoodIdx === -1) {
                                    bestFoodIdx = nIdx;
                                }
                            }
                        });

                        // Consume
                        if (bestFoodIdx !== -1) {
                            grid.value[bestFoodIdx].content.hp -= minConsumption;
                            // Check empty later
                        }

                        // --- Do Tasks ---
                        const adjacentTasks = [];
                        let hasBlackPerson = (p.id === 'p_black'); // Am I black?

                        neighbors.forEach(nIdx => {
                            const t = grid.value[nIdx].content;
                            if (t && t.type === 'task') {
                                // Black Task check
                                if (t.id === 't_black') {
                                    // Need black person neighbor. 
                                    // Current person is adjacent to task.
                                    // We need to check if ANY neighbor of the TASK is a black person.
                                    // Optimization: Just check if *this* person is black, or if other neighbors of task are black.
                                    // Actually, simpler: The task processes its own requirement? 
                                    // No, the person PUSHES progress.
                                    // If task is black, only push if *I* am black OR a black person is next to task.
                                    // Constraint: "If black person not adjacent, task does not progress".
                                    // So even if I am Red, I can push Black Task IF a Black Person is also there.
                                    const taskNeighbors = getNeighbors(nIdx);
                                    const blackPresent = taskNeighbors.some(tn => 
                                        grid.value[tn].content && grid.value[tn].content.id === 'p_black'
                                    );
                                    if (!blackPresent) return; 
                                }
                                adjacentTasks.push(nIdx);
                            }
                        });

                        if (adjacentTasks.length > 0) {
                            // Calculate total power
                            let power = 0;
                            // Need to know requirement per task. Logic says "Adjacent person capability advances gauge".
                            // If multiple tasks, "Force 11 to 2 tasks -> 6 and 6". 
                            // This implies we calculate power PER TASK type? No, usually power is generic.
                            // But tasks require STR or INT.
                            // Interpretation: Apply (STR or INT or BOTH) to EACH task, divided by count?
                            // Let's assume split logic applies to the *effort*.
                            // But the STAT used depends on the TASK.
                            // Implementation:
                            // 1. Calculate potential power for each task.
                            // 2. Sum them? No, split the "Action".
                            // Actually, the simplest interpretation of "Force 11 to 2 tasks -> 6 and 6" is:
                            // The person exerts effort on ALL adjacent tasks simultaneously, but intensity is split?
                            // Or is it full power to all? 
                            // "Force 11 to 2 tasks -> 6 and 6" means Force is a pool.
                            // So: Pool = Stat. Split Pool by N tasks. Ceiling.
                            
                            const count = adjacentTasks.length;
                            adjacentTasks.forEach(tIdx => {
                                const task = grid.value[tIdx].content;
                                let statVal = 0;
                                if (task.req === 'str') statVal = currentStr;
                                else if (task.req === 'int') statVal = currentInt;
                                else statVal = currentStr + currentInt; // Both

                                const amount = Math.ceil(statVal / count);
                                grid.value[tIdx].content.progress += amount;
                            });
                        }
                    });

                    // 3. Post-Process (Food Death / Task Complete)
                    // Food Death & Black Explosion
                    grid.value.forEach((cell, idx) => {
                        if (cell.content && cell.content.type === 'food') {
                            if (cell.content.hp <= 0) {
                                // Explosion?
                                if (cell.content.id === 'f_black') {
                                    const neighbors = getNeighbors(idx);
                                    neighbors.forEach(nIdx => {
                                        if (grid.value[nIdx].content && grid.value[nIdx].content.type === 'person') {
                                            grid.value[nIdx].content = null; // DEAD
                                        }
                                    });
                                }
                                cell.content = null; // Remove food
                            }
                        }
                    });

                    // Task Completion
                    grid.value.forEach((cell, idx) => {
                        if (cell.content && cell.content.type === 'task') {
                            if (cell.content.progress >= cell.content.maxProgress) {
                                // Reward
                                // We need rank of WHO? 
                                // "Reward x Rank". Which rank?
                                // Usually in these games, the task stores who worked on it? Too complex.
                                // Re-read: "Reward: 200k x Rank". 
                                // "Person Rank... affects Task Reward multiplier".
                                // This implies the Person's Rank modifies the reward generated by their work?
                                // OR: The Task checks adjacent people's rank?
                                // Let's simplify: Average Rank of adjacent people? Max Rank?
                                // Or maybe the money is added *during* work? No, "Completion".
                                // Let's take the MAX Rank of any adjacent person contributing.
                                const neighbors = getNeighbors(idx);
                                let maxRank = 1;
                                neighbors.forEach(nIdx => {
                                    if (grid.value[nIdx].content && grid.value[nIdx].content.type === 'person') {
                                        if (grid.value[nIdx].content.rank > maxRank) maxRank = grid.value[nIdx].content.rank;
                                    }
                                });
                                
                                money.value += Math.ceil(cell.content.reward * maxRank);
                                cell.content.progress = 0; // Reset
                            }
                        }
                    });
                };

                // --- Interaction Handlers ---

                const selectPaletteItem = (item) => {
                    selectedPaletteItem.value = item;
                };

                const handleCellClick = (index) => {
                    // Place Item
                    if (selectedPaletteItem.value && !grid.value[index].content) {
                        if (money.value >= selectedPaletteItem.value.cost) {
                            money.value -= selectedPaletteItem.value.cost;
                            // Clone object
                            const newItem = JSON.parse(JSON.stringify(selectedPaletteItem.value));
                            // Init dynamic props
                            if (newItem.type === 'person') newItem.rank = 1;
                            if (newItem.type === 'food') newItem.maxHp = newItem.hp;
                            if (newItem.type === 'task') { newItem.maxProgress = newItem.max; newItem.progress = 0; }
                            
                            grid.value[index].content = newItem;
                        }
                        return;
                    }

                    // Show Info / Delete
                    if (grid.value[index].content) {
                        selectedGridIndex.value = index;
                        showDetailModal.value = true;
                    }
                };

                const deleteItem = () => {
                    if (selectedGridIndex.value !== null) {
                        grid.value[selectedGridIndex.value].content = null;
                        showDetailModal.value = false;
                        selectedGridIndex.value = null;
                    }
                };

                const closeDetailModal = () => {
                    showDetailModal.value = false;
                    selectedGridIndex.value = null;
                };

                // --- Drag & Drop Logic (Touch) ---
                const handleTouchStart = (e, index) => {
                    if (!grid.value[index].content) return;
                    // Long press or immediate? Immediate for game feel usually better but conflicts with tap.
                    // Let's use a small delay or movement threshold to detect drag vs click.
                    // Actually, simple logic: Start tracking. If moved > 10px, it's a drag.
                    
                    const touch = e.touches[0];
                    dragStartIndex.value = index;
                    ghostX.value = touch.clientX - 40;
                    ghostY.value = touch.clientY - 40;
                    draggingContent.value = grid.value[index].content;
                    
                    // Don't set isDragging true yet (wait for move)
                };

                const handleTouchMove = (e) => {
                    if (dragStartIndex.value === null) return;
                    const touch = e.touches[0];
                    
                    if (!isDragging.value) {
                         isDragging.value = true;
                    }

                    ghostX.value = touch.clientX - 40;
                    ghostY.value = touch.clientY - 40;

                    // Identify target
                    const el = document.elementFromPoint(touch.clientX, touch.clientY);
                    const cell = el?.closest('.cell');
                    if (cell) {
                        // Find index in grid (Need a robust way, simple loop here)
                        // In Vue, we can't easily get index from DOM element without data attr.
                        // Let's rely on coordinate math or just loop rects.
                        // Simple approach: The grid structure is rigid.
                        // But elementFromPoint is easiest.
                        // Let's assume boardContainer is reference.
                        // Actually, finding index is tricky with just DOM. 
                        // Let's use logic: calculate based on board bounding rect.
                    }
                };
                
                // Better Drag Target Detection
                const getIndexFromCoords = (x, y) => {
                    if(!boardContainer.value) return null;
                    const rect = boardContainer.value.getBoundingClientRect();
                    const gridRect = boardContainer.value.querySelector('.grid').getBoundingClientRect();
                    
                    if (x < gridRect.left || x > gridRect.right || y < gridRect.top || y > gridRect.bottom) return null;

                    const colW = gridRect.width / 4;
                    const rowH = gridRect.height / 4;
                    
                    const col = Math.floor((x - gridRect.left) / colW);
                    const row = Math.floor((y - gridRect.top) / rowH);
                    
                    const idx = row * 4 + col;
                    if (idx >= 0 && idx < 16) return idx;
                    return null;
                };

                // Override TouchMove for Target Calc
                const customTouchMove = (e) => {
                    if (dragStartIndex.value === null) return;
                    if (!isDragging.value) isDragging.value = true;
                    const touch = e.touches[0];
                    ghostX.value = touch.clientX - 40;
                    ghostY.value = touch.clientY - 40;
                    
                    dragTargetIndex.value = getIndexFromCoords(touch.clientX, touch.clientY);
                };

                const handleTouchEnd = (e) => {
                    if (isDragging.value && dragStartIndex.value !== null && dragTargetIndex.value !== null) {
                        // Swap
                        const source = grid.value[dragStartIndex.value].content;
                        const target = grid.value[dragTargetIndex.value].content;
                        
                        grid.value[dragTargetIndex.value].content = source;
                        grid.value[dragStartIndex.value].content = target;
                    }
                    
                    // Reset
                    isDragging.value = false;
                    dragStartIndex.value = null;
                    dragTargetIndex.value = null;
                    draggingContent.value = null;
                };

                const getSkillEffectText = (content) => {
                    if (content.id === 's_red') return 'Âäõ+1';
                    if (content.id === 's_blue') return 'Áü•+1';
                    if (content.id === 's_green') return 'È£üÂçäÊ∏õ';
                    if (content.id === 's_black') return 'ÊòáÈÄ≤';
                    return '';
                };

                const getModalTitle = () => {
                    if (selectedGridIndex.value === null) return '';
                    const c = grid.value[selectedGridIndex.value].content;
                    return c ? c.name : '';
                };

                const getModalDesc = () => {
                    if (selectedGridIndex.value === null) return '';
                    const c = grid.value[selectedGridIndex.value].content;
                    return c ? c.desc : '';
                };

                const resetGame = () => {
                    money.value = 100;
                    timeLeft.value = 10;
                    phase.value = 'setup';
                    grid.value = Array(16).fill().map(() => ({ content: null }));
                    startGame();
                };

                onMounted(() => {
                    startGame();
                });

                return {
                    phase, money, formattedTime, grid, 
                    activeTab, selectedPaletteItem, currentCategoryItems,
                    selectPaletteItem, handleCellClick, 
                    showDetailModal, selectedGridIndex, closeDetailModal, deleteItem,
                    getModalTitle, getModalDesc, getSkillEffectText,
                    // Drag
                    handleTouchStart, handleTouchMove: customTouchMove, handleTouchEnd,
                    isDragging, ghostX, ghostY, draggingContent, dragTargetIndex,
                    boardContainer, resetGame
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
