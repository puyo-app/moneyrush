<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1ÂàÜ„ÅßÁ®º„Åê - 1min Money Rush</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #1a202c;
            color: #fff;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* Digital Clock Font */
        .font-digital {
            font-family: 'Black Ops One', cursive;
            font-variant-numeric: tabular-nums;
        }

        /* Grid & Cell Styling */
        .game-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            aspect-ratio: 1;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        .cell {
            background: #2d3748;
            border-radius: 8px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            touch-action: none; /* Important for custom drag */
        }
        .cell.active {
            border: 2px solid #fbbf24;
        }

        /* Panel Styling */
        .panel {
            width: 90%;
            height: 90%;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
            pointer-events: none; /* Let clicks pass to cell for handling */
        }
        
        /* Colors */
        .bg-red { background-color: #FF6B6B; color: #fff; }
        .bg-blue { background-color: #4ECDC4; color: #1a202c; }
        .bg-green { background-color: #95E1D3; color: #1a202c; }
        .bg-black { background-color: #2C3E50; color: #fff; border: 1px solid #4a5568; }

        /* Progress Bars */
        .bar-container {
            width: 80%;
            height: 4px;
            background: rgba(0,0,0,0.3);
            margin-top: 2px;
            border-radius: 2px;
            overflow: hidden;
        }
        .bar-fill { height: 100%; transition: width 0.2s linear; }
        .bar-food { background-color: #F6E05E; } /* Food: Yellow */
        .bar-task { background-color: #63B3ED; } /* Task: Blue */

        /* Floating Text Animation */
        .float-text {
            position: absolute;
            font-weight: bold;
            color: #fbbf24;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 50;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
        }

        /* Tabs */
        .tab-btn {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: #2d3748;
            color: #718096;
            font-weight: bold;
            font-size: 0.9rem;
        }
        .tab-btn.active {
            background: #4a5568;
            color: #fff;
            border-bottom: 3px solid #fbbf24;
        }

        /* Drag Ghost */
        .drag-ghost {
            position: fixed;
            width: 60px;
            height: 60px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: translate(-50%, -50%);
        }

        /* Shake Animation for No Money */
        .shake { animation: shake 0.3s; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
    </style>
</head>
<body>

<div id="app" class="h-screen w-screen flex flex-col overflow-hidden">

    <header class="p-3 bg-gray-800 flex justify-between items-center shadow-lg z-10">
        <div class="flex flex-col">
            <span class="text-xs text-gray-400">TIME LIMIT</span>
            <div class="font-digital text-3xl transition-colors duration-300" 
                 :class="gameState === 'setup' ? 'text-red-500' : 'text-white'">
                {{ displayTime }}
            </div>
        </div>
        <div class="text-right">
            <span class="text-xs text-gray-400">FUNDS</span>
            <div class="text-2xl font-bold text-yellow-400">
                {{ formatMoney(money) }}<span class="text-sm text-white"></span>
            </div>
        </div>
    </header>

    <main class="flex-1 flex flex-col items-center justify-center bg-gray-900 p-4 relative">
        
        <div v-if="gameState === 'result'" class="absolute inset-0 bg-black/80 z-50 flex flex-col items-center justify-center p-6 text-center">
            <h2 class="text-4xl font-bold text-white mb-4">FINISH!</h2>
            <p class="text-gray-300 mb-2">ÊúÄÁµÇÊâÄÊåÅÈáë</p>
            <div class="text-5xl font-bold text-yellow-400 mb-8 font-digital">{{ formatMoney(money) }}</div>
            <button @click="resetGame" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transform active:scale-95 transition">
                „ÇÇ„ÅÜ‰∏ÄÂ∫¶ÈÅä„Å∂
            </button>
        </div>

        <div class="game-grid" ref="gridRef">
            <div 
                v-for="(cell, index) in grid" 
                :key="index"
                class="cell"
                :class="{ 'active': selectedCellIndex === index }"
                @mousedown="handleInputStart(index, $event)"
                @touchstart.passive="handleInputStart(index, $event)"
                @mousemove="handleInputMove($event)"
                @touchmove.passive="handleInputMove($event)"
                @mouseup="handleInputEnd(index)"
                @touchend="handleInputEnd(index)"
            >
                <div v-if="cell" :class="['panel', getPanelColorClass(cell)]">
                    <div class="text-2xl mb-1">{{ getPanelIcon(cell) }}</div>
                    
                    <div v-if="cell.type === 'person'" class="text-[10px] leading-tight">
                        Rank {{ cell.rank.toFixed(1) }}<br>
                        Pw:{{cell.str}} In:{{cell.int}}
                    </div>
                    <div v-if="cell.type === 'food'" class="text-[10px] font-bold">
                        {{ cell.hp }}
                    </div>
                    <div v-if="cell.type === 'task'" class="text-[10px]">
                        {{ cell.hp }}/{{ cell.maxHp }}
                    </div>
                    <div v-if="cell.type === 'skill'" class="text-[10px]">
                        {{ getSkillName(cell) }}
                    </div>

                    <div v-if="cell.type === 'food'" class="bar-container">
                        <div class="bar-fill bar-food" :style="{ width: (cell.hp / cell.maxHp * 100) + '%' }"></div>
                    </div>
                    <div v-if="cell.type === 'task'" class="bar-container">
                        <div class="bar-fill bar-task" :style="{ width: ((cell.maxHp - cell.hp) / cell.maxHp * 100) + '%' }"></div>
                    </div>
                </div>
            </div>
        </div>

        <div v-for="ft in floatingTexts" :key="ft.id" class="float-text" :style="{ left: ft.x + 'px', top: ft.y + 'px' }">
            {{ ft.text }}
        </div>

    </main>

    <footer class="bg-gray-800 border-t border-gray-700 shadow-xl z-20 h-[35vh] flex flex-col">
        
        <div class="h-14 px-4 bg-gray-900 flex items-center justify-between border-b border-gray-700">
            <div v-if="selectedCellIndex !== null && grid[selectedCellIndex]" class="flex items-center w-full justify-between">
                <div class="text-sm text-gray-300">
                    <span class="font-bold text-white">{{ getPanelName(grid[selectedCellIndex]) }}</span>
                    <span v-if="grid[selectedCellIndex].type === 'person'" class="ml-2 text-xs">Â†±ÈÖ¨ÂÄçÁéá: x{{grid[selectedCellIndex].rank.toFixed(1)}}</span>
                </div>
                <button @click="deletePanel(selectedCellIndex)" class="bg-red-500 text-white px-3 py-1 rounded text-sm font-bold shadow active:scale-95">
                    Â£≤Âç¥ (+{{ Math.floor(grid[selectedCellIndex].cost * 0.5) }})
                </button>
            </div>
            <div v-else-if="selectedShopItem" class="flex items-center w-full justify-between">
                <div class="text-sm">
                    <span class="font-bold block" :class="canAfford(selectedShopItem) ? 'text-white' : 'text-red-400'">
                        {{ selectedShopItem.name }} ({{ selectedShopItem.cost }}‰∏á)
                    </span>
                    <span class="text-xs text-gray-400">{{ selectedShopItem.desc }}</span>
                </div>
            </div>
            <div v-else class="text-gray-500 text-sm">„Éë„Éç„É´„ÇíÈÅ∏Êäû„Åæ„Åü„ÅØÈÖçÁΩÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>
        </div>

        <div class="flex-1 overflow-x-auto p-2 flex items-center space-x-3 bg-gray-800">
            <div 
                v-for="(item, idx) in currentCategoryItems" 
                :key="idx"
                class="flex-shrink-0 w-16 h-20 bg-gray-700 rounded-lg flex flex-col items-center justify-center cursor-pointer border-2 relative transition-all"
                :class="[
                    selectedShopItem === item ? 'border-yellow-400 bg-gray-600' : 'border-transparent',
                    !canAfford(item) ? 'opacity-50' : ''
                ]"
                @click="selectShopItem(item)"
                @mousedown="handleShopDragStart(item, $event)"
                @touchstart.passive="handleShopDragStart(item, $event)"
            >
                <div class="text-2xl mb-1">{{ item.icon }}</div>
                <div class="text-xs font-bold text-center leading-none" :class="canAfford(item) ? 'text-white' : 'text-red-400'">
                    {{ item.cost }}‰∏á
                </div>
                <div class="absolute -top-1 -right-1 w-3 h-3 rounded-full" :class="getColorDot(item.color)"></div>
            </div>
        </div>

        <div class="flex border-t border-gray-700">
            <div class="tab-btn" :class="{ active: activeTab === 'person' }" @click="activeTab = 'person'">‰∫∫</div>
            <div class="tab-btn" :class="{ active: activeTab === 'food' }" @click="activeTab = 'food'">È£üÁâ©</div>
            <div class="tab-btn" :class="{ active: activeTab === 'task' }" @click="activeTab = 'task'">„Çø„Çπ„ÇØ</div>
            <div class="tab-btn" :class="{ active: activeTab === 'skill' }" @click="activeTab = 'skill'">„Çπ„Ç≠„É´</div>
        </div>
    </footer>

    <div v-if="dragState.isDragging" class="drag-ghost panel" :class="getPanelColorClass(dragState.item)" :style="{ left: dragState.x + 'px', top: dragState.y + 'px' }">
        <div class="text-2xl">{{ getPanelIcon(dragState.item) }}</div>
    </div>

</div>

<script>
const { createApp, ref, computed, onMounted, onUnmounted, reactive } = Vue;

createApp({
    setup() {
        // --- Game Constants & Data ---
        const ITEMS = {
            person: [
                { id: 'p_red', name: 'ËÇâ‰ΩìÊ¥æ', type: 'person', color: 'red', cost: 30, str: 15, int: 5, rank: 1.0, icon: 'üí™', desc: 'Âäõ‰ªï‰∫ã„ÅåÂæóÊÑè' },
                { id: 'p_blue', name: 'È†≠ËÑ≥Ê¥æ', type: 'person', color: 'blue', cost: 30, str: 5, int: 15, rank: 1.0, icon: 'üß†', desc: 'Áü•ÁöÑÂä¥ÂÉç„ÅåÂæóÊÑè' },
                { id: 'p_green', name: '„Éê„É©„É≥„Çπ', type: 'person', color: 'green', cost: 30, str: 10, int: 10, rank: 1.0, icon: '‚öñÔ∏è', desc: '‰∏áËÉΩÂûã' },
                { id: 'p_black', name: '‰Ωé„Çπ„Å∫', type: 'person', color: 'black', cost: 30, str: 5, int: 5, rank: 1.0, icon: '‚ôüÔ∏è', desc: 'ËÉΩÂäõ„ÅØ‰Ωé„ÅÑ„ÅåÈªíÊ°à‰ª∂„Å´ÂøÖÈ†à' },
            ],
            food: [
                { id: 'f_red', name: 'Ëµ§„ÅÆÈ£üÊñô', type: 'food', color: 'red', cost: 5, hp: 200, maxHp: 200, icon: 'üçñ', desc: 'Ëµ§„ÅÆ‰∫∫„ÅåÂ•ΩÁâ©' },
                { id: 'f_blue', name: 'Èùí„ÅÆÈ£üÊñô', type: 'food', color: 'blue', cost: 5, hp: 200, maxHp: 200, icon: 'üêü', desc: 'Èùí„ÅÆ‰∫∫„ÅåÂ•ΩÁâ©' },
                { id: 'f_green', name: 'ÈáéËèú', type: 'food', color: 'green', cost: 10, hp: 200, maxHp: 200, icon: 'ü•¶', desc: 'Ë™∞„Åß„ÇÇÁáÉË≤ªËâØ„Åó' },
                { id: 'f_black', name: 'Ë¨é„ÅÆËÇâ', type: 'food', color: 'black', cost: 0, hp: 200, maxHp: 200, icon: '‚ò†Ô∏è', desc: 'ÁÑ°„Åè„Å™„Çã„Å®Âë®Âõ≤„ÅåÊ≠ª‰∫°' },
            ],
            task: [
                { id: 't_red', name: 'ËÇâ‰ΩìÂä¥ÂÉç', type: 'task', color: 'red', cost: 0, hp: 0, maxHp: 300, icon: 'üì¶', reward: 25, desc: 'Âäõ„ÅßÈÄ≤Ë°å' },
                { id: 't_blue', name: 'È†≠ËÑ≥Âä¥ÂÉç', type: 'task', color: 'blue', cost: 0, hp: 0, maxHp: 300, icon: 'üíª', reward: 25, desc: 'Áü•„ÅßÈÄ≤Ë°å' },
                { id: 't_green', name: 'ÂçîÂäõÊ°à‰ª∂', type: 'task', color: 'green', cost: 0, hp: 0, maxHp: 400, icon: 'ü§ù', reward: 35, desc: 'ÂêàË®àÂÄ§„ÅßÈÄ≤Ë°å' },
                { id: 't_black', name: 'Â∑®Â§ßÊ°à‰ª∂', type: 'task', color: 'black', cost: 0, hp: 0, maxHp: 1000, icon: 'üè¢', reward: 100, desc: 'Èªí„ÅÑ‰∫∫„ÅåÈö£Êé•ÂøÖÈ†à' },
            ],
            skill: [
                { id: 's_red', name: '„ÉÄ„É≥„Éô„É´', type: 'skill', color: 'red', cost: 30, icon: 'üèãÔ∏è', desc: 'Èö£Êé•„ÅÆÂäõ„ÇíÊ∞∏Á∂öÂº∑Âåñ' },
                { id: 's_blue', name: 'ÊäÄË°ìÊõ∏', type: 'skill', color: 'blue', cost: 30, icon: 'üìö', desc: 'Èö£Êé•„ÅÆÁü•„ÇíÊ∞∏Á∂öÂº∑Âåñ' },
                { id: 's_green', name: 'Ë¶≥ËëâÊ§çÁâ©', type: 'skill', color: 'green', cost: 30, icon: 'üåø', desc: 'Èö£Êé•„ÅÆÊ∂àË≤ª„Ç´„É≠„É™„ÉºÂçäÊ∏õ' },
                { id: 's_black', name: 'ÊòáÈÄ≤Ëæû‰ª§', type: 'skill', color: 'black', cost: 30, icon: 'üìú', desc: '10ÁßíÊØé„Å´Âë®Âõ≤„ÇíÊòáÈÄ≤' },
            ]
        };

        // --- State ---
        const gameState = ref('setup'); // setup, playing, result
        const time = ref(10); // Setup starts at 10
        const money = ref(100);
        const grid = ref(new Array(16).fill(null));
        const activeTab = ref('person');
        const selectedShopItem = ref(null);
        const selectedCellIndex = ref(null);
        const floatingTexts = ref([]);
        
        // Drag State
        const dragState = reactive({
            isDragging: false,
            item: null, // Data object of what is being dragged
            sourceIndex: null, // If from grid, index. If from shop, null.
            x: 0,
            y: 0
        });

        // Loop vars
        let lastTime = 0;
        let animationFrameId = null;
        let skillTimer = 0; // For 1 sec tick skills
        let blackSkillTimer = 0; // For 10 sec black skill

        // --- Core Logic ---

        // Helpers
        const getNeighbors = (idx) => {
            const neighbors = [];
            const row = Math.floor(idx / 4);
            const col = idx % 4;
            const deltas = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right
            
            deltas.forEach(([dr, dc]) => {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < 4 && nc >= 0 && nc < 4) {
                    const nIdx = nr * 4 + nc;
                    if (grid.value[nIdx]) {
                        neighbors.push({ ...grid.value[nIdx], index: nIdx, originalRef: grid.value[nIdx] });
                    }
                }
            });
            return neighbors;
        };

        // Game Loop
        const gameLoop = (timestamp) => {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (gameState.value === 'setup') {
                time.value -= deltaTime;
                if (time.value <= 0) {
                    time.value = 60;
                    gameState.value = 'playing';
                }
            } else if (gameState.value === 'playing') {
                time.value -= deltaTime;
                if (time.value <= 0) {
                    time.value = 0;
                    gameState.value = 'result';
                    return; // End loop
                }
                updateGameLogic(deltaTime);
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        };

        const updateGameLogic = (dt) => {
            // Skill Timers
            skillTimer += dt;
            blackSkillTimer += dt;
            const triggerPassive = skillTimer >= 1.0;
            const triggerBlack = blackSkillTimer >= 10.0;

            if (triggerPassive) skillTimer = 0;
            if (triggerBlack) blackSkillTimer = 0;

            // Process Grid
            grid.value.forEach((cell, idx) => {
                if (!cell) return;

                // --- Skill Effects ---
                if (cell.type === 'skill') {
                    const neighbors = getNeighbors(idx);
                    neighbors.forEach(n => {
                        const target = grid.value[n.index]; // Direct reference
                        if (target.type === 'person') {
                            if (cell.color === 'red' && triggerPassive) target.str += 1;
                            if (cell.color === 'blue' && triggerPassive) target.int += 1;
                            if (cell.color === 'black' && triggerBlack) {
                                target.rank = Math.min(2.0, target.rank + 0.1);
                                spawnFloatText('ÊòáÈÄ≤!', idx);
                            }
                        }
                    });
                }

                // --- Person Logic ---
                if (cell.type === 'person') {
                    const neighbors = getNeighbors(idx);
                    
                    // 1. Eat Food
                    const foods = neighbors.filter(n => n.type === 'food');
                    let canWork = false;

                    if (foods.length > 0) {
                        // Priority: Own Color (Favorite) > Green (Super) > Others
                        // Sort logic: Lower index is better
                        foods.sort((a, b) => {
                            const isFavA = (a.color === cell.color) || (a.color === 'green');
                            const isFavB = (b.color === cell.color) || (b.color === 'green');
                            return (isFavB ? 1 : 0) - (isFavA ? 1 : 0); // true comes first
                        });

                        const foodToEat = grid.value[foods[0].index];
                        
                        // Check for Green Skill (Plant) neighbor to halve consumption
                        const hasGreenSkill = neighbors.some(n => n.type === 'skill' && n.color === 'green');
                        
                        // Consumption Rate
                        let consumeAmount = 20; // Default Bad
                        if (foodToEat.color === cell.color || foodToEat.color === 'green' || foodToEat.color === 'black') {
                            consumeAmount = 10; // Good/Neutral
                        }
                        if (hasGreenSkill) consumeAmount *= 0.5;

                        // Apply Consumption
                        foodToEat.hp -= consumeAmount * dt;
                        canWork = true;

                        // Food Depletion & Black Food Death Logic
                        if (foodToEat.hp <= 0) {
                            if (foodToEat.color === 'black') {
                                // Kill surrounding people
                                const foodNeighbors = getNeighbors(foods[0].index);
                                foodNeighbors.forEach(fn => {
                                    if (fn.type === 'person') {
                                        grid.value[fn.index] = null; // DIE
                                        spawnFloatText('Ê≠ª‰∫°...', fn.index);
                                    }
                                });
                            }
                            grid.value[foods[0].index] = null; // Remove Food
                        }
                    }

                    // 2. Work on Tasks
                    if (canWork) {
                        const tasks = neighbors.filter(n => n.type === 'task');
                        if (tasks.length > 0) {
                            // Calculate Work Power
                            let power = 0;
                            // Black Task Logic: Only progress if a Black Person is adjacent
                            // The Person logic just provides power, the Task logic validates it.
                            // However, strictly: "Èö£Êé•„Åô„Çã‰∫∫„ÅåÊï∞ÂÄ§„Çí„Çø„Çπ„ÇØ„Å´‰∏é„Åà„Çã"
                            
                            // Distribute power among tasks
                            const powerShare = 1 / tasks.length;
                            
                            tasks.forEach(t => {
                                const taskRef = grid.value[t.index];
                                
                                // Specific Logic: Black Task needs Black Person
                                if (taskRef.color === 'black') {
                                    // Check if task neighbors include a black person
                                    const taskNeighbors = getNeighbors(t.index);
                                    const hasBlackPerson = taskNeighbors.some(tn => tn.type === 'person' && tn.color === 'black');
                                    if (!hasBlackPerson) return; // No progress
                                }

                                // Calculate contribution
                                let contribution = 0;
                                if (taskRef.color === 'red') contribution = cell.str;
                                else if (taskRef.color === 'blue') contribution = cell.int;
                                else if (taskRef.color === 'green') contribution = cell.str + cell.int;
                                else if (taskRef.color === 'black') contribution = cell.str + cell.int;

                                // Apply
                                // Note: Rank DOES NOT multiply work speed, only reward.
                                taskRef.hp += contribution * powerShare * dt;

                                // Completion Check
                                if (taskRef.hp >= taskRef.maxHp) {
                                    taskRef.hp = 0;
                                    // Reward Calculation: Base * Person Rank
                                    const reward = Math.floor(taskRef.reward * cell.rank);
                                    money.value += reward;
                                    spawnFloatText(`+${reward}‰∏á`, t.index);
                                }
                            });
                        }
                    }
                }
            });
        };

        // --- Interaction ---

        const selectShopItem = (item) => {
            selectedShopItem.value = item;
            selectedCellIndex.value = null; // Deselect board
        };

        const canAfford = (item) => {
            return money.value >= item.cost;
        };

        const deletePanel = (idx) => {
            if (grid.value[idx]) {
                money.value += Math.floor(grid.value[idx].cost * 0.5);
                grid.value[idx] = null;
                selectedCellIndex.value = null;
            }
        };

        // Drag & Drop / Input Logic
        const gridRef = ref(null);

        const getGridIndexFromClientPos = (cx, cy) => {
            if (!gridRef.value) return null;
            const rect = gridRef.value.getBoundingClientRect();
            // Check bounds
            if (cx < rect.left || cx > rect.right || cy < rect.top || cy > rect.bottom) return null;
            
            // Calculate relative pos
            const relX = cx - rect.left;
            const relY = cy - rect.top;
            const cellW = rect.width / 4;
            const cellH = rect.height / 4;
            
            const col = Math.floor(relX / cellW);
            const row = Math.floor(relY / cellH);
            return row * 4 + col;
        };

        // Input Handlers (Unified Mouse/Touch)
        const handleShopDragStart = (item, event) => {
            if (!canAfford(item)) return;
            selectShopItem(item); // Also select it
            
            // Prevent default drag for touch to handle manually
            // event.preventDefault(); 
            
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            startDrag(item, null, clientX, clientY);
        };

        const handleInputStart = (index, event) => {
            // If dragging from shop, ignore
            if (dragState.isDragging) return;

            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            // Logic:
            // 1. If shop item selected -> Place on Tap (handled in End/Click, but we track press)
            // 2. If board item -> Select it. Also Start Drag logic.

            if (selectedShopItem.value) {
                // Wait for release to place
            } else if (grid.value[index]) {
                selectedCellIndex.value = index;
                startDrag(grid.value[index], index, clientX, clientY);
            } else {
                // Clicked empty space
                selectedCellIndex.value = null;
            }
        };

        const startDrag = (item, sourceIdx, x, y) => {
            dragState.isDragging = true;
            dragState.item = item; // Clone basics for visual
            dragState.sourceIndex = sourceIdx;
            dragState.x = x;
            dragState.y = y;
        };

        const handleInputMove = (event) => {
            if (!dragState.isDragging) return;
            event.preventDefault(); // Stop scrolling
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            dragState.x = clientX;
            dragState.y = clientY;
        };

        const handleInputEnd = (dropIndex) => {
            if (dragState.isDragging) {
                // Determine drop target based on coordinate (more reliable than event target for touch)
                const targetIndex = getGridIndexFromClientPos(dragState.x, dragState.y);
                
                // DRAG LOGIC
                if (targetIndex !== null && targetIndex >= 0 && targetIndex < 16) {
                    if (dragState.sourceIndex === null) {
                        // Shop -> Grid (Buy)
                        buyAndPlace(dragState.item, targetIndex);
                    } else {
                        // Grid -> Grid (Move/Swap)
                        if (dragState.sourceIndex !== targetIndex) {
                            // Swap
                            const temp = grid.value[targetIndex];
                            grid.value[targetIndex] = grid.value[dragState.sourceIndex];
                            grid.value[dragState.sourceIndex] = temp;
                            selectedCellIndex.value = targetIndex; // Follow selection
                        }
                    }
                }
            } else {
                // TAP LOGIC (No drag occurred or very short)
                // If Shop Item Selected and we tapped a cell
                if (selectedShopItem.value && dropIndex !== undefined) {
                    buyAndPlace(selectedShopItem.value, dropIndex);
                }
            }
            
            // Reset
            dragState.isDragging = false;
            dragState.item = null;
            dragState.sourceIndex = null;
        };

        const buyAndPlace = (itemTmpl, idx) => {
            if (!canAfford(itemTmpl)) return;

            // Deep clone new item
            const newItem = JSON.parse(JSON.stringify(itemTmpl));
            // Initialize dynamic properties
            if (newItem.type === 'person') newItem.rank = 1.0;
            
            // Deduct money
            money.value -= newItem.cost;
            
            // Place (Overwrite or Fill)
            // Note: If swapping with existing panel via Shop placement, old is deleted (simple logic)
            // Or we could say "Swap" but usually shop placement overwrites.
            // Let's implement: If occupied, Sell old, then place New.
            if (grid.value[idx]) {
                money.value += Math.floor(grid.value[idx].cost * 0.5); // Refund half
            }
            
            grid.value[idx] = newItem;
        };

        // --- Visuals ---
        const displayTime = computed(() => {
            if (gameState.value === 'setup') {
                return Math.ceil(time.value);
            }
            const m = Math.floor(time.value / 60);
            const s = Math.floor(time.value % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        });

        const currentCategoryItems = computed(() => {
            return ITEMS[activeTab.value];
        });

        const formatMoney = (val) => {
            return Math.floor(val).toLocaleString() + '‰∏áÂÜÜ';
        };

        const getPanelColorClass = (item) => {
            if (!item) return '';
            return `bg-${item.color}`;
        };
        const getColorDot = (color) => {
            return `bg-${color === 'black' ? 'gray-900 border border-white' : (color + '-500')}`;
        };

        const getPanelIcon = (item) => item.icon;
        const getPanelName = (item) => item.name;
        const getSkillName = (item) => {
            if(item.color === 'red') return "ÂäõUP";
            if(item.color === 'blue') return "Áü•UP";
            if(item.color === 'green') return "ÁúÅ„Ç®„Éç";
            if(item.color === 'black') return "ÊòáÈÄ≤";
        }

        const spawnFloatText = (text, idx) => {
            // Simple visual effect
            const row = Math.floor(idx / 4);
            const col = idx % 4;
            // Get approximate px position
            if (!gridRef.value) return;
            const rect = gridRef.value.children[idx].getBoundingClientRect();
            
            floatingTexts.value.push({
                id: Date.now() + Math.random(),
                text: text,
                x: rect.left + rect.width / 4,
                y: rect.top,
            });

            // Cleanup
            setTimeout(() => {
                floatingTexts.value.shift();
            }, 1000);
        };

        const resetGame = () => {
            grid.value = new Array(16).fill(null);
            money.value = 100;
            time.value = 10;
            gameState.value = 'setup';
            skillTimer = 0;
            blackSkillTimer = 0;
            lastTime = 0;
        };

        onMounted(() => {
            animationFrameId = requestAnimationFrame(gameLoop);
        });
        
        onUnmounted(() => {
            cancelAnimationFrame(animationFrameId);
        });

        return {
            gameState, time, displayTime, money, grid, 
            activeTab, currentCategoryItems, selectedShopItem, selectedCellIndex,
            dragState, gridRef, floatingTexts,
            selectShopItem, canAfford, deletePanel,
            handleInputStart, handleInputMove, handleInputEnd, handleShopDragStart,
            formatMoney, getPanelColorClass, getPanelIcon, getPanelName, getColorDot, getSkillName,
            resetGame
        };
    }
}).mount('#app');
</script>
</body>
</html>
